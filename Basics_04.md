# 4. Dive into Python :)


## Переменные в Python: определение, типы данных.

Мы с вами уже освоили вопросы типизаций в целом, теперь переходим к практическому материалу на языке Python.

**Python - язык со строгой динамической типизацией.**

**Динамическая типизация** означает, что одну и ту же переменную можно сначала инициализировать строкой, потом числом, потом булевым значением, и так далее. Языки со статической типизацией, как язык C, Java, подобного не позволяют.

**Строгая типизация** означает, что язык сам не меняет тип переменной в зависимости от ее использования. К примеру, если прибавить к числу строку, в которой записано число, язык выдаст ошибку.

Далее представлены переменные различных основных типов языка:

```python
my_integer = 4     #целые числа
my_float = 4.12    #дробные числа
my_str = 'aaaa'      #строки
my_bool = True     #True, False, правда или ложь, булевы значения
my_list = [1, 2, 3, 'x'] # список с разнородными элементами
my_tuple = (1, [2]) # неизменяемая последовательность
my_dict = {'2':2, '3':3} # неупорядоченная последовательность
my_set = set((1, 2, 3, 2, 1)) # множество
>>> my_set
{1, 2, 3}
```

Здесь мы увидели числа, целые и дробные, строку, булеву переменную, список, кортеж, множество и словарь.


## Простейшие математические операции с целыми числами
Над целыми и дробными числами доступны математические операции умножения (+), деления (/), вычитания (-), сложения (+), возведения в степень (**) и получение остатка от деления (%):

```python
int1 = 4
int2 = 8
result = int1 + int2      # result = 12
result = int2 - int1      # result = 4
result = int1 * int2      # result = 32
result = (int2+1) / int1  # result = 2
result = int2 ** int1     # result = 4096
result = (int2+1) % int1  # result = 1
```

## Вывод данных

Для вывода данных используется функция `print`:

```python
int1 = 4
str1 = "8"
print(int1)   #выведет 4
print('text') #выведет text
print("text") #выведет text
print(str1)   #выведет 8
```

## Оператор условия if

В python в отличие от множества других языков существует только один оператор условия `if -> elif -> else`

```python
print ("Give it to me!")
number = int(input())

if (number >= 100):
    print ("Thanks, man!")
elif ((number > 10) and (number < 100)):
    print ("OK :(")
else:
    print ("WHAAAAT????")

if (number > 1000):
    print ("!!!!WOOOOWWWW!!!")

```


Обратите внимание, мы впервые сталкиваемся с блоком операторов. Так же будет и у циклов, и у функций, и у классов, и у их методов, и так далее. блок операторов начинается со своего инициатора (например, сейчас это блок оператора if), после инициатора ставится двоеточие, затем все действия, которые программист хочет выполнять в рамках этого блока, он должен выполнять после одного дополнительного отступа. Если отступа не будет, python будет воспринимать это как код вне блока.

Есть возможность применять оператор if в нескольких вариантах. Ниже приведен список всех вариантов:

* if (условие) действие
* if (условие) (блок действий в несколько строк)
* if (условие) (блок действий в несколько строк) else действие
* if (условие) (блок действий в несколько строк) else (блок действий в несколько строк)
* if (условие) (блок действий в несколько строк) elif(условие) (блок действий в несколько строк) else действие
* if (условие) (блок действий в несколько строк) elif(условие) (блок действий в несколько строк) else (блок действий в несколько строк)

**Между if и else может быть сколько угодно elif.**

## Операторы сравнения и приоритеты операций

В отличии от языка С, в Python операторы сравнения имеют одинаковый приоритет.

Результатом сравнений является ответ типа `bool` - **`True`** или **`False`**.

В отличии от многих других языков, Python похволяет использовать цепочки операторов сравнения, т.е. классическое для программирования двойное сравнение может быть заменено цепочкой:

```python
>>> x = 5
>>> y = 10
>>> z = 15

>>> (x < y) and (y <= z)
True

>>> x < y <= z
True
```

К операторам сравнения относятся следующие:

```
"<"      - меньше 
">"      - больше
"=="     - равно
">="     - больше или равно
"<="     - меньше или равно
"!="     - не равно
"not"    - не является чем-то
"is"     - является тем же самым
"is not" - не является тем-же самым
"in"     - является частью чего-то
"not in" - не является частью чего-то
```

Последние четыре оператора нуждаются в дополнительном пояснении.

Оператор `is` проверяет, являются ли оба операнда одним и тем же объектом в памяти, тогда как простое сравнение на равенство `==` проверяет только на соответствие содержимого двух операндов, но не проверяет, являются ли они одним и тем же объектом.

```python
>>> l1 = [1, 2, 3]
>>> l2 = [1, 2, 3]
>>> l1 == l2
True
>>> l1 is l2
False
>>> l1 is not l2
True
```

Оператор **`in`** проверяет, включает ли операнд справа тот операнд, что слева:

```python
>>> 3 in l1
True
>>> 4 in l1
False
>>> 5 not in l1
True
```

## Альтернативный синтаксис if, замена тернарному оператору

Во многих языках программирования (С++, Java, PHP...) существуют тернарный оператор, т.е. специальный оператор условия, который возвращает один из двух результатов, в зависимости от того, выполняется его условие или нет. Выглядит он так:

```php
print ($input == 1) ? "One!" : "Not One!";
```

Тернарные операторы часто применяются, когда варианта всего два, так как такая запись короче аналогичного действия с if. Однако, к сожалению, можно встретить связку if-ов и тернарных операторов, которую совершенно невозможно прочесть. Другими словами, это не необходимая вещь в языке и она может стать причиной нечитаемого текста.

В python нет тернарного оператора, но есть возможность его имитировать при помощи if:

```python
test = True
result = 'Test is True' if test else 'Test is False'
# result = 'Test is True'
```

Это можно использовать с любыми функциями, как и с печатью:

```python
test = True
print ('ttt' if test else 'fff') # выведет ttt
```

## Особенности сравнения объектов

В языке Python все является объектом. Когда мы говорим о числе, строке, функции. классе, списке и т.д. - мы говорим об объекте.

Python считает, что если объект не пуст, он True, а не False. False - это собственно сам False, 0 и пустая строка. Таким образом если нам необходимо сравнить строку с пустой строкой, или число с нулем, а так же узнать, является ли пустым тот или иной объект, вместо того, чтобы писать условия в стиле старых языков:

```python
if s !='':
    pass
    
if 8 % 2 != 0:
    pass
```

можно слегка их сократить:

```python
if s:
    pass
    
if 8 % 2:
    pass
```

Это значительно сокращает и упрощает код.








## Изменяемые и неизменяемые типы данных

В Python есть изменяемые (mutable) и неизменяемые (immutable) типы данных.

Ранее рассматривался тип данных int, который является неизменяемым. Так же неизменяемыми являются типы данных tuple (кортеж) и string (строка).

Что значит неизменяемыми? Значит, что изначально созданную строку мы изменить не можем. Это легко покажут дальнейшие примеры со строками и кортежами. Если же кажется, что объект одного из перечисленных данных изменился - значит теперь имя объекта просто указывает на новую область в памяти с новым объектом.

## Строки

### Создание строк, кавычки

В python между одинарными и двойными кавычками практически нет разницы, а ведь есть еще два вида тройных. Все типы кавычек могут быть вставлены друг в друга. Тройные так же позволяют вставлять переход на новую строку внутрь строки:

```python
S1 = 'Welcome to strings'
S2 = "Another string"
S3 = """And '''another'''
long
string"""
S4 = 'This "string" is a bit """crazy"""'
```

### Простые операции

Простейшие арифметические операции сложения и умножения доступны и со строками. В примере ниже - сложение двух строк (конкатенация), умножение строки на число и взятие конкретного элемента строки по его индексу. Индексы во всех последовательностях в программировании считаются от нуля. По отрицательному индексу - отсчитываем от конца строки назад.

```python
S = 'abc'
print(len(S)) # Выведет 3
S = S + '12' # В S будет 'abc12'
print(S[2])   # Выведет 'c'
print('ab'*2) # Выведет abab
```

### Строка - неизменяемый тип

Теперь давайте проверим, насколько неизменяемы строки и как с этим бороться:

```python
S = 'asdfghj'
S[5] = 's'
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'str' object does not support item assignment
# Python ругается, строки такую операцию не поддерживают. Ок...
S = S[:5] + 's' + S[6:]
```


### Срезы строк

Python позволяет взять или даже составить из элементов строки любую подстроку, используя slices (срезы). Примеры:

```python
>>> S = "Welcome to California!"
>>> S
'Welcome to California!'
>>> S[:5] # от начала показать пять элементов
'Welco'
>>> S[5:] # от пятого элемента и дальше
'me to California!'
>>> S[:] # показать всю строку
'Welcome to California!'
>>> S[:-3] # Показать до третьего элемента с конца
'Welcome to Californ'
>>> S[::-1] # Показать всю строку задом наперед
'!ainrofilaC ot emocleW'
>>> S[:5:2] # Показать до пятого элемента с шагом два
'Wlo'
```

Из примера видно, что срезы создаются путем указания в квадратных скобок обязательного двоеточия. Число до двоеточия - от какого элемента показывать, после - до какого, не включая его. Если не указано первое число - показывать от начала, если не указано второе - до конца. Второе двоеточие позволяет указать третье число - шаг, с которым нужно идти по последовательности.

### Полезные функции работы со строками

```python
>>> S
'Welcome to California!'
>>> len(S) # получить длину строки
22
>>> S.find('C') # найти индекс начала первой подстроки в строке
11
>>> S.replace('C', '7') # Заменяет все подстроки на новые
'Welcome to 7alifornia!'
>>> S.split() # Разбивает строку по разделителю и создает список. По умолчанию разделитель - пробел['Welcome', 'to', 'California!']>>> S.upper()
'WELCOME TO CALIFORNIA!'
>>> S += '\n\n'
>>> S
'Welcome to California!\n\n'
>>> S.rstrip() # удаление пробельных символов в конце
'Welcome to California!'
```

Дополнительную информацию о строках и функциях работы с ними можно найти по ссылке:
[Подробнее о строках](http://rtfm.co.ua/python_s_nulya/python-s-nulya-chast-7-stroki/)

## Домашка

[Домашнее задание](hw4.md)

[Python online](https://repl.it/languages/python3)